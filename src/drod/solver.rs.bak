use std::collections::{HashMap, VecDeque};
use std::fmt::{Display, Formatter, Result};
use std::io::Write;
use std::ops::{AddAssign, SubAssign};
use std::rc::Rc;
use std::u8;

use rust_dense_bitset::BitSet as _;
use rust_dense_bitset::DenseBitSet as RoomSet;
use rust_dense_bitset::DenseBitSet as BitSet;

use super::model::{Level, GE, PlayerCombat, PlayerFlag, PlayerObjective, PlayerScore, PlayerStat, ProbeStat, RoomType};

type VertexIDType = u8;

pub struct PlayerProgressDiff {
    pub counter: i8,        // ignore
    pub visited: BitSet,
    pub memory: BitSet,     // ignore
    pub location: VertexIDType,
}

impl Default for PlayerProgressDiff {
    fn default() -> Self {
        Self {
            counter: 0,
            visited: BitSet::new(),
            memory: BitSet::new(),
            location: u8::MAX,
        }
    }
}

impl From<PlayerStat> for PlayerProgressDiff {
    fn from(stat: PlayerStat) -> Self {
        Self {
            counter: 0,
            visited: BitSet::new(),
            memory: BitSet::new(),
            location: u8::MAX,
        }
    }
}

#[derive(Default)]
struct Player {
    pub hp: i32,
    pub flag: PlayerFlag,
    pub atk: i16,
    pub def: i16,
    pub equip_flag: PlayerFlag,
    pub equip_atk: i16,
    pub equip_def: i16,
    pub gr: i16,
    pub yk: i8,
    pub gk: i8,
    pub bk: i8,
    pub counter: i8,        // ignore
    pub visited: BitSet,
    pub memory: BitSet,     // ignore
    pub disabled: BitSet,   // ignore
    pub neighbors: BitSet,  // ignore
    pub diff: PlayerProgressDiff,
}

impl From<Player> for PlayerScore {
    fn from(player: Player) -> Self{
        // TODO support alternative score functions
        Self {
            score: (player.hp + 1) * 25 + (player.atk as i32 * 5 + player.def as i32 * 3 + player.yk as i32 * 10 + player.gk as i32 * 20 + player.bk as i32 * 30) * 1000
        }
    }
}

impl From<Player> for PlayerProgress {
    fn from(player: Player) -> Self {
        Self {
            counter: 0,
            visited: player.visited,
            memory: BitSet::new(),
        }
    }
}

impl From<Player> for PlayerObjective {
    fn from(player: Player) -> Self {
        Self {
            hp: player.hp
        }
    }
}

impl From<Player> for PlayerStat {
    fn from(player: Player) -> Self {
        Self {
            hp: player.hp,
            flag: player.flag,
            atk: player.atk,
            def: player.def,
            equip_flag: player.equip_flag,
            equip_atk: player.equip_atk,
            equip_def: player.equip_def,
            gr: player.gr,
            yk: player.yk,
            gk: player.gk,
            bk: player.bk,
            counter: 0,
        }
    }
}

impl From<Player> for PlayerCombat {
    fn from(player: Player) -> Self {
        Self {
            flag: player.flag,
            atk: player.atk,
            def: player.def,
            equip_flag: player.equip_flag,
            equip_atk: player.equip_atk,
            equip_def: player.equip_def,
            counter: 0,
        }
    }
}

impl GE<PlayerStat> for Player {
    fn ge(&self, other: &PlayerStat) -> bool {
        self.hp >= other.hp
            && self.flag.contains(other.flag)
            && self.atk >= other.atk
            && self.def >= other.def
            && self.equip_flag.contains(other.equip_flag)
            && self.equip_atk >= other.equip_atk
            && self.equip_def >= other.equip_def
            && self.gr >= other.gr
            && self.yk >= other.yk
            && self.gk >= other.gk
            && self.bk >= other.bk
        // ignore counter
    }
}

impl AddAssign<PlayerStat> for Player {
    fn add_assign(&mut self, other: PlayerStat) {
        self.hp += other.hp;
        self.flag ^= other.flag;
        self.atk += other.atk;
        self.def += other.def;
        self.equip_flag ^= other.equip_flag;
        self.equip_atk += other.equip_atk;
        self.equip_def += other.equip_def;
        self.gr += other.gr;
        self.yk += other.yk;
        self.gk += other.gk;
        self.bk += other.bk;
        // ignore counter
    }
}

impl From<PlayerObjective> for Player {
    fn from(objective: PlayerObjective) -> Self{
        Self {
            hp: objective.hp,
            ..Default::default()
        }
    }
}

impl Player {
    pub fn reverted_progress(&self) -> PlayerProgress {
        let progress = PlayerProgress::from(*self);
        progress -= self.diff;
        progress
    }

    pub fn enter(&self, level: &Level) -> &Self {
        self.neighbors.set_bit(level.entrance as usize, true);
        self
    }

    pub fn visit(&self, location: VertexIDType, level: &Level, probe: &ProbeStat) -> &Self {
        // TODO support closed level
        *self += probe.diff;
        self.diff = probe.diff.into();
        self.visited.set_bit(location as usize, true);
        self.neighbors &= !level.toggle_neighbors[location as usize];
        self.neighbors &= !self.visited;
        self.diff.location = location;
        self
    }

    pub fn print(&self, writer: &dyn Write, level: &Level) {
        write!(writer, "Score {}\n{{", PlayerScore::from(self));
        todo!()
    }
}

#[derive(Eq)]
pub struct PlayerProgress {
    pub counter: i8,        // ignore
    pub visited: BitSet,
    pub memory: BitSet,     // ignore
}

impl SubAssign<PlayerProgressDiff> for PlayerProgress {
    fn sub_assign(&mut self, other: PlayerProgressDiff) {
        // TODO support closed level
        self.visited ^= other.visited;
        // ignore counter, memory
    }
}

pub struct PlayerTrace {
    pub level_config: i32,
    // pub level,
    pub player: Player,
    pub trace: Vec<VertexIDType>,
}

impl From<PlayerTrace> for PlayerScore {
    fn from(trace: PlayerTrace) -> Self {
        trace.player.into()
    }
}

impl From<PlayerTrace> for PlayerStat {
    fn from(trace: PlayerTrace) -> Self {
        trace.player.into()
    }
}

impl PlayerTrace {
    fn visit(&self, vertex: VertexIDType) -> &Self {
        todo!()
    }
}

pub fn print_room_list<T: Iterator<Item = u8>>(writer: &dyn Write, level: &Level, list: T) {
    let first = true;
    for room in list {
        if first {
            first = false;
        }
        else {
            write!(writer, ", ");
        }
        write!(writer, "{}", level.vertex_of_id(room).name);
    }
    writeln!(writer, "");
}


// An iterator for DenseBitSet that returns the position of each enabled bit in the set
struct BitSetIter(RoomSet);

impl From<RoomSet> for BitSetIter {
    fn from(bitset: RoomSet) -> Self {
        Self(bitset)
    }
}

impl Iterator for BitSetIter {
    type Item = u8;

    // Return position of next enabled bit in set
    fn next(&mut self) -> Option<Self::Item> {
        if self.0.none() {
            None
        } else {
            let first_set = self.0.first_set();
            assert!(first_set < 64);
            self.0.set_bit(first_set as usize, false);
            Some(first_set as u8)
        }
    }
}

// Represents state of player and choices after visiting a set of rooms
#[derive(Debug)]
struct RouteState {
    player: Player,
    neighbors: RoomSet,
    visited: RoomSet,
    last_visit: u8,
}

impl RouteState {
    fn new(player: Player, level: &Level) -> Self {
        let neighbors = RoomSet::from_integer(1 << level.entrance);
        Self {
            player,
            neighbors,
            visited: RoomSet::new(),
            last_visit: u8::MAX,
        }
    }

    // Find route state after visiting a room
    fn visit(&mut self, room_id: u8, level: &Level, probe: &ProbeStat) {
        let idx = room_id as usize;
        self.player += probe.diff;
        self.neighbors |= level.neighbors[idx];
        self.neighbors &= !level.toggle_neighbors[idx];
        self.neighbors &= !self.visited;
        self.last_visit = room_id;
        self.visited.set_bit(idx, true);
    }

    fn previous_visited(&self) -> RoomSet {
        let idx = self.last_visit as usize;
        let mut rooms = self.visited;
        rooms.set_bit(idx, false);
        rooms
    }
}

// Represents full route through a level
#[derive(Clone, Debug)]
pub struct Route {
    player: Player,
    level: Rc<Level>,
    trace: Vec<u8>,
    neighbors: RoomSet,
    visited: RoomSet,
    previous_visited: RoomSet,
}

impl Route {
    fn new(player: Player, level: Rc<Level>) -> Self {
        let neighbors = RoomSet::from_integer(1 << level.entrance);
        Self {
            player,
            level,
            trace: Vec::new(),
            neighbors,
            visited: RoomSet::new(),
            previous_visited: RoomSet::new(),
        }
    }

    // Add room to route
    fn visit(&mut self, room_id: u8) {
        let idx = room_id as usize;
        assert!(self.neighbors.get_bit(idx));
        let probe = self.level.vertex_of_id(room_id).probe(&self.player.into());
        assert!(self.player.dominate(&probe.req));

        self.player += probe.diff;
        self.trace.push(room_id);
        self.neighbors |= self.level.neighbors[idx];
        self.neighbors &= !self.level.toggle_neighbors[idx];
        self.neighbors &= !self.visited;
        self.previous_visited = self.visited;
        self.visited.set_bit(idx, true);
    }
}

impl Display for Route {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result {
        let mut trace_str = String::new();
        let mut first = true;
        for id in &self.trace {
            if first {
                first = false;
            } else {
                trace_str += ", ";
            }
            trace_str += &self.level.vertex_of_id(*id).name;
        }
        write!(f, "{}\n\nTrace: {}", self.player, trace_str)
    }
}

// Stores auxillary data about probing a room
struct ExtendedProbeStat {
    probe: ProbeStat,
    room_id: u8,
    free: bool,
    priority: bool,
}

pub struct Solution {
    optimal_route: Route,
    local_optimal_routes: Vec<Route>,
}

impl Display for Solution {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result {
        let mut local_route_str = String::new();
        for route in &self.local_optimal_routes {
            local_route_str += &route.to_string();
            local_route_str += "\n--------------------------------------------------------------------------------\n";
        }

        write!(
            f,
            "Local Optimal Routes:\n{}Most Optimal Route:\n{}",
            local_route_str, self.optimal_route
        )
    }
}
